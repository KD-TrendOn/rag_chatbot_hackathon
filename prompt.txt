├── Dockerfile
├── app/
│   ├── __init__.py
│   ├── api/
│   │   ├── __init__.py
│   │   └── endpoints.py
│   ├── chunks_creating.py
│   ├── config.py
│   ├── database/
│   │   ├── __init__.py
│   │   └── vector_store.py
│   ├── graphs/
│   │   ├── __init__.py
│   │   └── main_graph.py
│   ├── logger.py
│   ├── main.py
│   ├── photo_indexes.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── chat.py
│   │   ├── message.py
│   │   ├── state.py
│   │   └── user.py
│   └── services/
│       ├── __init__.py
│       └── llm.py
├── core/
│   ├── __init__.py
│   ├── config.py
│   └── models/
│       ├── __init__.py
│       ├── base.py
│       ├── chat.py
│       ├── crud.py
│       ├── db_helper.py
│       ├── message.py
│       └── user.py
├── docker-compose.yml
├── images/
└── requirements.txt

Dockerfile



app/__init__.py



app/api/__init__.py



app/api/endpoints.py

# app/api/endpoints.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
import uuid
import aiofiles
import os
from ...core.models.crud import (
    create_user,
    get_user_by_user_id,
    create_chat,
    create_message,
    get_last_five_chats_with_last_message,
    get_last_n_messages,
)
from ...core.models.db_helper import db_helper
from ...core.models.chat import Chat
from ..services.llm import worker  # Предполагается, что worker доступен из llm.py
from ..schemas.state import State
from ..schemas.chat import ChatHistoryResponse, ChatWithLastMessageResponse
from ..schemas.message import SendMessageResponse, SendMessageRequest, PhotoInfo
from ..schemas.user import UserCreateResponse
from PIL import Image
import pytesseract
from io import BytesIO
import base64
from datetime import datetime

router = APIRouter()

@router.post("/user", response_model=UserCreateResponse)
async def new_user(session: AsyncSession = Depends(db_helper.session_dependency)):
    """
    Создает нового пользователя с уникальным user_id.
    """
    try:
        # Генерация нового UUID
        new_uuid = str(uuid.uuid4())
        new_user = await create_user(session=session, user_id=new_uuid)
        return UserCreateResponse(user_id=new_user.user_id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/last/{user_id}", response_model=List[ChatWithLastMessageResponse])
async def get_last_five_chat_by_id(
        user_id: str,
        session: AsyncSession = Depends(db_helper.session_dependency)
):
    """
    Получает последние пять чатов пользователя идентификатора user_id.
    """
    try:
        # Проверяем существование пользователя
        user = await get_user_by_user_id(session, user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Получаем последние пять чатов с последними сообщениями
        chats_with_messages = await get_last_five_chats_with_last_message(session, user_id, limit=5)
        return chats_with_messages
    except HTTPException as he:
        raise he
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/send_message", response_model=SendMessageResponse)
async def send_message(
    request: SendMessageRequest,
    session: AsyncSession = Depends(db_helper.session_dependency)
):
    """
    Отправляет сообщение пользователем в чат и возвращает ответ от бота.
    Поддерживает отправку изображений в формате Base64.
    """
    user_id = request.user_id
    chat_id = request.chat_id
    message = request.message
    images = request.images

    # Проверка существования пользователя
    user = await get_user_by_user_id(session, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Проверка существования чата
    chat = await session.get(Chat, chat_id)
    if not chat:
        raise HTTPException(status_code=404, detail="Chat not found")
    
    # Обработка отправленных изображений (Base64)
    image_texts = []
    if images:
        for img in images:
            try:
                # Декодирование Base64 в байты
                image_data = base64.b64decode(img.data)
                
                # Сохранение изображения на сервер
                file_path = os.path.join("uploads", img.filename)
                os.makedirs("uploads", exist_ok=True)
                async with aiofiles.open(file_path, 'wb') as out_file:
                    await out_file.write(image_data)
                
                # Конвертация изображения в текст с помощью OCR
                img_pil = Image.open(BytesIO(image_data))
                text = pytesseract.image_to_string(img_pil, lang='rus')  # Предполагаем, что текст на русском
                image_texts.append(text)
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Ошибка обработки изображения {img.filename}: {e}")

    # Комбинирование текста сообщения и текста из изображений
    if image_texts:
        combined_message = f"{message}\n" + "\n".join(image_texts)
    else:
        combined_message = message
    
    # Сохранение сообщения пользователя в базе данных
    try:
        await create_message(session, chat, "user", combined_message)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка сохранения сообщения: {e}")
    
    # Получение последних 5 сообщений из чата для контекста
    try:
        last_messages_objs = await get_last_n_messages(session, chat, limit=5)
        # Формирование списка кортежей (sender, content)
        last_messages = [(msg.sender, msg.content) for msg in last_messages_objs]
        # Добавление текущего сообщения пользователя для формирования контекста
        last_messages.append(("user", combined_message))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка получения истории чата: {e}")
    
    # Инициализация состояния
    initial_state: State = {
        "user_message": combined_message,
        "last_messages": last_messages,
        "is_index": False,
        "answer": "",
        "rel_docs": [],
        "db_query": "",
        "retries": 0,
        "rewrite": False
    }
    
    # Вызов worker для обработки состояния
    try:
        response_state = await worker.ainvoke(initial_state)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при вызове worker: {e}")
    
    # Получение ответа бота и его сохранение
    bot_answer = response_state.get("answer", "")
    try:
        await create_message(session, chat, "bot", bot_answer)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка сохранения ответа бота: {e}")
    
    # Обработка rel_docs для отправки фотографий
    photos_info = []
    if response_state.get("rel_docs"):
        for doc in response_state["rel_docs"]:
            for chapter, details in doc.items():
                content = details.get("content", "")
                image_paths = details.get("paths", [])
                for path in image_paths:
                    # Извлечение номера главы и номера рисунка из имени файла
                    filename = os.path.basename(path)
                    parts = filename.split('_')
                    if len(parts) < 2:
                        continue  # Неверный формат имени файла
                    chapter_num = parts[0]
                    image_num_part = parts[1].split('.')[0]  # Пример: 'image1.png' -> 'image1'
                    image_num = ''.join(filter(str.isdigit, image_num_part))  # Извлекаем только цифры
                    
                    # Чтение изображения и кодирование в Base64
                    try:
                        with open(path, "rb") as image_file:
                            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
                    except Exception as e:
                        raise HTTPException(status_code=500, detail=f"Ошибка чтения изображения {path}: {e}")
                    
                    photos_info.append(PhotoInfo(
                        chapter=chapter_num,
                        image_number=image_num,
                        base64_data=encoded_string
                    ))
    
    return SendMessageResponse(
        user_message=combined_message,
        bot_answer=bot_answer,
        photos=photos_info
    )


app/chunks_creating.py

import re
from docx import Document as DocxDocument
from langchain.schema import Document
import photo_indexes
import os

# Чтение текста из файла .docx
def load_text_from_docx(file_path):
    doc = DocxDocument(file_path)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return "\n".join(full_text)

# Путь к твоему файлу .docx
file_path = "documentation_preprocessed.docx"

# Загружаем текст из файла
text_content = load_text_from_docx(file_path)

# titles из твоего словаря заголовков, включая Аннотацию и КОНТАКТНУЮ ИНФОРМАЦИЮ
titles = photo_indexes.titles
titles["Аннотация"] = "Аннотация"
titles["КОНТАКТНАЯ ИНФОРМАЦИЯ"] = "КОНТАКТНАЯ ИНФОРМАЦИЯ"

# Регулярное выражение для поиска заголовков, включая их название (добавлены "Аннотация" и "КОНТАКТНАЯ ИНФОРМАЦИЯ")
heading_pattern = re.compile(r"(\d+(\.\d+)*|Аннотация|КОНТАКТНАЯ ИНФОРМАЦИЯ)")

# Функция для разделения текста на части по заголовкам (включая название)
def split_text_by_headings(text: str, titles: dict):
    documents = []
    matches = list(heading_pattern.finditer(text))
    
    for i in range(len(matches)):
        start = matches[i].start()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(text)
        
        chapter = matches[i].group(1).strip()  # номер главы или специальный заголовок
        chapter_title = titles.get(chapter, "Неизвестный заголовок")  # заголовок из словаря titles
        
        # Извлечение содержимого между заголовками (включая заголовок)
        content = text[start:end].strip()
        
        # Поиск связанных путей к фотографиям для данной главы
        image_paths = get_files_by_number(chapter)  # используем ранее написанную функцию

        # Создаем объект Document с метаданными
        doc = Document(
            page_content=content[:1000],
            metadata={
                "content":content,
                "chapter": chapter,
                "title": chapter_title,
                "paths": image_paths
            }
        )
        documents.append(doc)
    
    return documents

# Получение файлов по номеру главы (реализуй эту функцию)
def get_files_by_number(number):
    # Здесь функция get_files_by_number уже должна быть реализована
    # для получения путей к фоткам, которые соответствуют главе
    return [f for f in os.listdir("images") if f.startswith(str(number)+'_')]

# Применяем функцию для разделения текста
documents = split_text_by_headings(text_content, titles)
print(len(documents))
# Выводим результат
# count = 10
# for doc in documents:
#     print(f"{doc.metadata['chapter']}, Заголовок: {doc.metadata['title']}")
#     print(f"Пути к фоткам: {doc.metadata['paths']}")
#     print(f"Содержимое:\n{len(doc.page_content), doc.page_content}") 
#     if count==-1:
#         break
#     count -=1
#     print()

app/config.py

from dotenv import load_dotenv
import os

load_dotenv()

class Settings:
    YANDEXGPT_IAM_TOKEN:str=os.getenv("YANDEXGPT_IAM_TOKEN")
    YANDEXGPT_MODEL_URI:str=os.getenv("YANDEXGPT_MODEL_URI")
    YANDEXGPT_MAIN_MODEL_URI:str=os.getenv("YANDEX_MAIN_MODEL_URI")
    EMBEDDINGS_MODEL:str=os.getenv("EMBEDDINGS_MODEL")
    DEVICE:str=os.getenv("DEVICE")
    PG_CONNECTION:str=os.getenv("PG_CONNETCTION")
    PG_COLLECTION_NAME:str=os.getenv("PG_COLLECTION_NAME")


settings = Settings()

app/database/__init__.py



app/database/vector_store.py

from functools import lru_cache
from langchain_postgres import PGVector
from ..config import settings
from ..chunks_creating import documents

from langchain.embeddings.base import Embeddings
import time
import requests
from typing import Any, List, Mapping, Optional
from langchain.callbacks.manager import CallbackManagerForLLMRun
import requests
import langchain

class YandexGPTEmbeddings(Embeddings):

    def __init__(self, iam_token=None, api_key=None, folder_id=None, sleep_interval=1):
        self.iam_token = iam_token
        self.sleep_interval = sleep_interval
        self.api_key = api_key
        self.folder_id = folder_id
        if self.iam_token:
            self.headers = {'Authorization': 'Bearer ' + self.iam_token}
        if self.api_key:
            self.headers = {'Authorization': 'Api-key ' + self.api_key,
                             "x-folder-id" : self.folder_id }
                
    def embed_document(self, text):
        j = {
          "model" : "general:embedding",
          "embedding_type" : "EMBEDDING_TYPE_DOCUMENT",
          "text": text
        }
        res = requests.post("https://llm.api.cloud.yandex.net/llm/v1alpha/embedding",
                            json=j, headers=self.headers)
        vec = res.json()['embedding']
        return vec

    def embed_documents(self, texts, chunk_size = 0):
        res = []
        for x in texts:
            res.append(self.embed_document(x))
            time.sleep(self.sleep_interval)
        return res
        
    def embed_query(self, text):
        j = {
          "model" : "general:embedding",
          "embedding_type" : "EMBEDDING_TYPE_QUERY",
          "text": text
        }
        res = requests.post("https://llm.api.cloud.yandex.net/llm/v1alpha/embedding",
                            json=j,headers=self.headers)
        vec = res.json()['embedding']
        time.sleep(self.sleep_interval)
        return vec
    

@lru_cache
def get_vectorstore() -> PGVector:
    embeddings = YandexGPTEmbeddings(iam_token=settings.YANDEXGPT_IAM_TOKEN)
    vectorstore = PGVector(
        embeddings=embeddings,
        collection_name=settings.PG_COLLECTION_NAME,
        connection=settings.PG_CONNECTION,
        use_jsonb=True,
        async_mode=True,
    )
    return vectorstore

vectorstore = get_vectorstore()

vectorstore.add_documents(documents=documents)

app/graphs/__init__.py



app/graphs/main_graph.py

from typing import Dict, Any, Literal, TypedDict
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables.config import RunnableConfig
from ..schemas.state import State
from ..services.llm import llm_light, llm_pro
from ..logger import setup_logger
from langchain_core.output_parsers import StrOutputParser
from ..database.vector_store import get_vectorstore

logger = setup_logger(__name__)

graph = StateGraph(State)

general_answer = """Данный вопрос определен как не связанный с руководством пользователя, пожалуйста попробуйте снова или обратитесь в наш отдел технической поддержки."""

async def classify_index(state:State) -> State:  # -> Literal["index", "general"]:
    with open("index_summary.txt", "r") as f:
        index = f.read()
    prompt_template = """
    Ты - оператор чат бота, задача которого отвечать на вопросы пользователей связанные с руководством приложения. Ты должен определить связан ли вопрос конкретно с программой или руководством или он на общую тему.
    Тебе будет дан текущий запрос пользователя и выжимка из руководства пользователя. Ты должен вернуть ответ строго одним словом, либо 'Да' либо 'Нет'.
    Напиши 'Да' если текущий вопрос пользователя связан с программой или руководством и 'Нет' если текущий вопрос пользователя идет на отвлеченную тему.
    Выжимка из руководства:

    {summary}

    Последние сообщения пользователя:

    {user_context}

    Текущий вопрос пользователя

    {user_message}

    Ответ:
    """
    prompt = PromptTemplate.from_template(prompt_template)
    bound = prompt | llm_light | StrOutputParser()
    response:str = await bound.ainvoke({
        "summary":index,
        "user_context":"\n".join([el[1] for el in state["last_messages"] if el[0] == "user"]),
        "user_message":state["user_message"]
    })
    if response.replace("'", "").lower() == "нет" or response.replace("'", "").lower().endswith("нет"):
        return {"is_index":False, "answer":general_answer, "rel_docs":[]}
    else:
        return {"is_index":True}

def route_index(state:State) -> Literal["get_relevant_docs", "__end__"]:
    if state["is_index"]:
        return "get_relevant_docs"
    else:
        return END

# doc_schema:
# {"1.1.1(.1)":{"text":str, "images":list[str]("paths")}}
# {"1.1.1.1":Document()}

async def get_relevant_docs(state:State) -> State:
    vectorstore = get_vectorstore()
    return {'rel_docs':[{el.metadata["chapter"]:{"text":el.metadata["content"], "images":el.metadata["image_paths"]}} for el in await vectorstore.asimilarity_search(query=state["db_query"])]}

async def score_docs(state:State)->State:
    new_rel_docs=[]
    prompt_template="""
    Ты - оператор чат бота помощника по руководству по сайту Сила. Твоя задача по предоставленному запросу пользователя определить является ли предложенный раздел документации подходящим.
    В руководстве могут быть описаны инструкции, помощь с обработкой ошибок, навигацией по сайту. Ответ должен состоять из одного слова, либо 'Да', либо 'Нет'.
    Отвечай 'Да' если документ релевантен запросу и его можно учитывать при генерации ответа.
    Отвечай 'Нет' если документ не поможет пользователю в решении вопроса или он второстепенный. 
    Важно не путать пользователя лишними инструкциями поэтому определяй осторожно.
    
    Текущий вопрос пользователя:
    
    {user_message}
    
    Документ на оценку:
    
    {doc_check}
    
    Ответ:"""
    prompt = PromptTemplate.from_template(prompt_template)
    bound = prompt | llm_light | StrOutputParser()
    for doc in state["rel_docs"]:
        response = await bound.ainvoke({
            "user_message":state["user_message"],
            "doc_check":doc.values()["text"]
        })
        if response.replace("'", "").lower() == "нет" or response.replace("'", "").lower().endswith("нет"):
            continue
        else:
            new_rel_docs.append(doc)
    if len(new_rel_docs) == 0:
        return {"rewrite":True, "rel_docs":[], "retries":state['retries'] + 1}
    else:
        return {"rewrite":False, "rel_docs":new_rel_docs}

contact_message = """Ответ на ваш вопрос не найден среди документов руководства пользователя. Если Вам требуется квалифицированная помощь, позвоните на телефон «горячей линии поддержки», напишите письмо или воспользуйтесь формой регистрации заявки на сайте. 
КОНТАКТНАЯ ИНФОРМАЦИЯ
Техническая поддержка
+7 (495) 258-06-36
info@lense.ru
lense.ru
"""

def route_docs(state:State) -> Literal["rewrite_query", "no_docs", "generate"]:
    if state["retries"] >= 2:
        return "no_docs"
    elif state["rewrite"]:
        return "rewrite_query"
    else:
        return "generate"


async def rewrite_query(state:State) -> State:
    prompt_template = """Ты - оператор чат бота, помощника пользователя по сайту Сила. Чат бот проводит поиск релевантных документов из руководства пользователя для ответа на вопрос.
    Прошлый поиск не удался, поэтому твоя задача перефразировать и изменить запрос к векторной базе данных привел к правильным результатом.
    Твой ответ должен быть строкой, которая упоминает нужные компоненты или действия на сайте. Перефразируй запрос пользователя более формально, чтобы по ключевым словам и смыслу запроса нашшлись нужные документы.
    Краткая выжимка из руководства пользователя:
    
    {summary}
    
    Сообщение пользователя:
    
    {user_message}
    
    Неудавшийся запрос:

    {last_query}

    Ответ:"""
    prompt = PromptTemplate.from_template(prompt_template)
    bound = prompt | llm_light | StrOutputParser()
    with open("index_summary.txt", "r") as f:
        index = f.read()
    return {"db_query": await bound.ainvoke({"summary": index, "user_message":state['user_message'], "last_query":state["db_query"]})}


def no_docs(state:State) -> State:
    return {"answer":contact_message}

async def generate(state:State)-> State:
    prompt_template = """
    Ты - чат бот, задача которого помочь пользователю в использовании платформы Сила. Для ответа будет предоставлена история чата, текущий вопрос пользователя, и несколько релевантных документов из руководства пользователя.
    Твоя задача использовать полученный контекст для ответа на вопрос пользователя. Самое главное не запутать его, но дать нужный совет сославшись на документацию.
    Можешь упомянуть картинки из текста, или помочь пользователю с навигацией или если проблема не решается, то направить его в тех поддержку.
    Шаблон сообщения для направления пользователя в тех поддержку при возникших трудностях:
    {contact_message}

    Документы руководства пользователя связанные с запросом.

    {rel_docs}

    Последние сообщения пользователя:

    {user_context}

    Текущий вопрос пользователя

    {user_message}

    Ответ:"""
    prompt = PromptTemplate.from_template(prompt_template)
    bound = prompt | llm_pro | StrOutputParser()
    response:str = await bound.ainvoke({
        "contact_message":contact_message,
        "rel_docs":"\n\n".join([el.values()[0]["text"] for el in state['rel_docs']]),
        "user_context":"\n".join([f"{el[0]}: {el[1]}" for el in state["last_messages"]]),
        "user_message":state["user_message"]
    })
    return {"answer":response}

async def score_answer(state:State) -> State:
    prompt_template = """
    Ты - оператор чат бота, задача которого отвечать на вопросы пользователей связанные с руководством приложения. Ты должен оценить сгенерированный чат ботом ответ.
    Тебе будет дан текущий запрос пользователя, релевантные документы и ответ чат бота. Ты должен вернуть ответ строго одним словом, либо 'Да' либо 'Нет'.
    Напиши 'Да' если текущий ответ удовлетворительный и сможет помочь пользователю с решением проблемы и дает нужные инструкции и 'Нет' если текущий вопрос пользователя остался не решенным.
    Релевантные документы из руководства пользователя:

    {rel_docs}

    Последние сообщения пользователя:

    {user_context}

    Текущий вопрос пользователя

    {user_message}

    Ответ чат бота на оценку:

    {answer}

    Твоя оценка:
    """
    prompt = PromptTemplate.from_template(prompt_template)
    bound = prompt | llm_light | StrOutputParser()
    response:str = await bound.ainvoke({
        "rel_docs":"\n\n".join([el.values()[0]["text"] for el in state['rel_docs']]),
        "user_context":"\n".join([f"{el[0]}: {el[1]}" for el in state["last_messages"]]),
        "user_message":state["user_message"],
        "answer":state["answer"]
    })
    if response.replace("'", "").lower() == "нет" or response.replace("'", "").lower().endswith("нет"):
        return {"rewrite":True, "answer":contact_message, "rel_docs":[],"retries":state["retries"] + 1}
    else:
        return {"rewrite":False}

def route_answer(state:State) -> Literal["rewrite_query", "__end__"]:
    if state["rewrite"]:
        return "rewrite_query"
    return END

graph.add_node(classify_index)
graph.add_node(get_relevant_docs)
graph.add_node(score_docs)
graph.add_node(rewrite_query)
graph.add_node(no_docs)
graph.add_node(generate)
graph.add_node(score_answer)
graph.set_entry_point("classify_index")
graph.add_conditional_edges("classify_index", route_index)
graph.add_edge("get_relevant_docs", "score_docs")
graph.add_conditional_edges("score_docs", route_docs)
graph.add_edge("rewrite_query", "get_relevant_docs")
graph.add_edge("generate", "score_answer")
graph.set_finish_point("no_docs")
graph.add_conditional_edges("score_answer", route_answer)
worker = graph.compile()

app/logger.py

import logging
from logging.handlers import RotatingFileHandler
import os

def setup_logger(name):
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)

    # Создаем директорию для логов, если она не существует
    if not os.path.exists('logs'):
        os.makedirs('logs')

    # Настраиваем RotatingFileHandler
    file_handler = RotatingFileHandler(
        'logs/app.log', maxBytes=10485760, backupCount=5)
    file_handler.setLevel(logging.INFO)

    # Настраиваем ConsoleHandler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)

    # Создаем форматтер и добавляем его к обработчикам
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    # Добавляем обработчики к логгеру
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger


app/main.py



app/photo_indexes.py

import os

# Полная структура заголовков с ключами в кавычках
titles = {
    "1": "О системе",
    "1.1": "Наименование и обозначение системы",
    "1.2": "Область применения системы",
    "1.3": "Основные функции системы",
    "1.4": "Роли пользователей",
    "2": "Работа в системе",
    "1.5": "Запуск системы",
    "1.6": "Авторизация",
    "1.7": "Просмотр информации о системе",
    "1.8": "Настройка шлюзов автоматизации",
    "1.8.1": "Добавление шлюза",
    "1.8.2": "Статусы шлюза",
    "1.8.3": "Состояния шлюза",
    "1.8.4": "Удаление шлюза",
    "1.9": "Управление учетными записями",
    "1.9.1": "Создание УЗ",
    "1.9.2": "Редактирование УЗ",
    "1.9.3": "Удаление УЗ",
    "1.10": "Иерархия моделей ПО",
    "1.10.1": "Уровни моделей ПО",
    "1.10.2": "Создание модели ПО",
    "1.10.3": "Добавление связей между моделями ПО",
    "1.10.4": "Переименование модели ПО",
    "1.10.5": "Редактирование свойств модели ПО",
    "1.10.6": "Редактирование свойств применимости модели ПО",
    "1.10.7": "Удаление связей между моделями ПО",
    "1.10.8": "Удаление модели ПО",
    "1.11": "Управление шаблонами",
    "1.11.1": "Выбор актуальной версии шаблона",
    "1.11.2": "Загрузка и обновление шаблона",
    "1.11.3": "Создание шаблона",
    "1.11.4": "Выгрузка шаблонов",
    "1.12": "Управление профилями",
    "1.12.1": "Создание профиля из списка профилей",
    "1.12.2": "Копирование профиля",
    "1.12.3": "Создание профиля через перечень шаблонов",
    "1.12.4": "Редактирование требований профиля",
    "1.12.5": "Переименование профиля",
    "1.12.6": "Смена применимости профиля",
    "1.12.7": "Активация профиля",
    "1.12.8": "Архивация профиля",
    "1.12.9": "Удаление профиля",
    "1.13": "Управление требованиями",
    "1.13.1": "Добавление раздела",
    "1.13.2": "Переименование раздела",
    "1.13.3": "Перемещение раздела",
    "1.13.4": "Удаление раздела",
    "1.13.5": "Создание требования",
    "1.13.6": "Добавление сведений",
    "1.13.7": "Добавление применимости",
    "1.13.8": "Добавление данных сбора конфигурации",
    "1.13.9": "Добавление данных анализа конфигурации",
    "1.13.10": "Добавление данных исправления конфигурации",
    "1.13.11": "Добавление требования из Единого реестра требований",
    "1.13.12": "Переименование требования",
    "1.13.13": "Редактирование данных требования",
    "1.13.14": "Смена применимости требования",
    "1.13.15": "Использование отметки «Черновик»",
    "1.13.16": "Удаление требования",
    "1.14": "Управление ресурсами",
    "1.14.1": "Добавление раздела",
    "1.14.2": "Переименование раздела",
    "1.14.3": "Перемещение раздела",
    "1.14.4": "Удаление раздела",
    "1.14.5": "Создание online-ресурса",
    "1.14.6": "Создание offline-ресурса",
    "1.14.7": "Переименование ресурса",
    "1.14.8": "Перемещение ресурса",
    "1.14.9": "Редактирование данных ресурса",
    "1.14.10": "Редактирование программной топологии",
    "1.14.11": "Добавление экземпляра ПО",
    "1.14.11.1": "Добавление экземпляра уровеня 1",
    "1.14.11.2": "Добавление экземпляра уровеня 2",
    "1.14.12": "Редактирование экземпляра ПО",
    "1.14.13": "Импорт и экспорт ресурсов",
    "1.14.13.1": "Содержимое файла экспорта",
    "1.14.13.2": "Импорт ресурса",
    "1.14.13.3": "Экспорт ресурса",
    "1.14.14": "Удаление экземпляра ПО",
    "1.14.15": "Удаление ресурса",
    "1.15": "Аудит конфигурации ПО",
    "1.15.1": "Создание области аудита",
    "1.15.2": "Редактирование области аудита",
    "1.15.3": "Задачи на аудит",
    "1.15.4": "Запуск задачи",
    "1.15.5": "Отмена задачи",
    "1.15.6": "Просмотр отчета аудита",
    "1.15.6.1": "Просмотр отчета",
    "1.15.6.2": "Группировка подзадач",
    "1.15.6.3": "Скачивание отчета",
    "1.15.7": "Просмотр протокола аудита",
    "1.15.7.1": "Просмотр протокола",
    "1.15.7.2": "Статистика проверок",
    "1.15.7.3": "Список требований",
    "1.15.7.4": "Смена отображения требований",
    "1.15.7.5": "Фильтрация требований",
    "1.15.8": "Завершение протокола аудита",
    "1.15.8.1": "Завершение сбора конфигурации",
    "1.15.8.2": "Завершение анализа конфигурации",
    "1.15.9": "Удаление области аудита",
    "3": "Дополнительная информация",
    "1.16": "Сообщения об ошибках",
}

# Путь к папке images
images_folder = "images"

# Получаем список всех файлов в папке images
all_files = os.listdir(images_folder)
print(all_files)


# Функция для проверки, начинается ли имя файла с определенного номера
def get_files_by_number(number):
    return [f for f in all_files if f.startswith(str(number)+'_')]


# Создаем словарь для хранения названий файлов по заголовкам
files_by_titles = {}

# Заполняем словарь
for number in titles:
    files_by_titles[number] = get_files_by_number(number)

# Выводим результат
for title_number, files in files_by_titles.items():
    print(f"Заголовок {title_number}: {titles[title_number]}")
    print(f"Файлы: {files}")


app/schemas/__init__.py



app/schemas/chat.py

# app/schemas/chat.py
from pydantic import BaseModel
from datetime import datetime
from typing import List

class LastMessageSchema(BaseModel):
    sender: str
    content: str
    timestamp: datetime

class ChatWithLastMessageResponse(BaseModel):
    chat_id: int
    last_message: LastMessageSchema


app/schemas/message.py

# app/schemas/message.py
from pydantic import BaseModel, Field, validator
from typing import List, Dict, Optional
import base64

class MessageImage(BaseModel):
    filename: str
    data: str  # Base64-encoded image data

    @validator('data')
    def validate_base64(cls, v):
        try:
            base64.b64decode(v)
        except Exception:
            raise ValueError('Invalid base64 encoding')
        return v

class SendMessageRequest(BaseModel):
    user_id: str
    chat_id: int
    message: str
    images: Optional[List[MessageImage]] = None  # Опционально список изображений

class PhotoInfo(BaseModel):
    chapter: str
    image_number: str
    base64_data: str  # Base64-encoded image data

class SendMessageResponse(BaseModel):
    user_message: str
    bot_answer: str
    photos: List[PhotoInfo]


app/schemas/state.py

from typing import TypedDict, Tuple

class State(TypedDict):
    user_message:str
    last_messages:list[Tuple]
    is_index:bool
    answer:str
    rel_docs:list[dict]
    db_query:str
    retries:int
    rewrite:bool

app/schemas/user.py

# app/schemas/user.py
from pydantic import BaseModel

class UserCreateResponse(BaseModel):
    user_id: str


app/services/__init__.py



app/services/llm.py

from ..config import settings
from langchain_community.llms import YandexGPT

llm_light = YandexGPT(iam_token=settings.YANDEXGPT_IAM_TOKEN, model_uri=settings.YANDEXGPT_MODEL_URI)
llm_pro = YandexGPT(iam_token=settings.YANDEXGPT_IAM_TOKEN, model_uri=settings.YANDEXGPT_MAIN_MODEL_URI)

core/__init__.py



core/config.py

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    DB_ECHO: bool = False
    POSTGRES_HOST: str
    POSTGRES_PORT: int
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    # Добавьте другие необходимые настройки

    class Config:
        env_file = "db.env"

settings = Settings()


core/models/__init__.py

# core/models/__init__.py
from .user import User
from .chat import Chat
from .message import Message

__all__ = ["User", "Chat", "Message"]


core/models/base.py

from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, declared_attr

class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr.directive
    def __tablename__(cls) -> str:
        return f"{cls.__name__.lower()}s"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)


core/models/chat.py

# core/models/chat.py
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .user import User
    from .message import Message

class Chat(Base):
    __tablename__ = "chats"
    
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column()
    user: Mapped["User"] = relationship("User", back_populates="chats")
    messages: Mapped[list["Message"]] = relationship("Message", back_populates="chat")


core/models/crud.py

# core/models/crud.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc, func
from typing import List, Optional
from .user import User
from .chat import Chat
from .message import Message

from ...app.schemas.chat import ChatWithLastMessageResponse, LastMessageSchema

async def create_user(session: AsyncSession, user_id: str) -> User:
    user = User(user_id=user_id)
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user

async def get_user_by_user_id(session: AsyncSession, user_id: str) -> Optional[User]:
    result = await session.execute(select(User).where(User.user_id == user_id))
    return result.scalar_one_or_none()

async def create_chat(session: AsyncSession, user: User) -> Chat:
    chat = Chat(user_id=user.id)
    session.add(chat)
    await session.commit()
    await session.refresh(chat)
    return chat

async def create_message(session: AsyncSession, chat: Chat, sender: str, content: str) -> Message:
    message = Message(chat_id=chat.id, sender=sender, content=content)
    session.add(message)
    await session.commit()
    await session.refresh(message)
    return message

async def get_last_five_chats_with_last_message(session: AsyncSession, user_id: str, limit: int = 5) -> List[ChatWithLastMessageResponse]:
    """
    Получает последние пять чатов пользователя вместе с последним сообщением в каждом чате.
    """
    # Подзапрос для получения времени последнего сообщения в каждом чате
    subquery = (
        select(
            Message.chat_id,
            func.max(Message.timestamp).label("last_message_time")
        )
        .join(Chat, Chat.id == Message.chat_id)
        .join(User, User.id == Chat.user_id)
        .where(User.user_id == user_id)
        .group_by(Message.chat_id)
        .subquery()
    )
    
    # Основной запрос для получения чатов и их последних сообщений
    stmt = (
        select(Chat, Message)
        .join(subquery, Chat.id == subquery.c.chat_id)
        .join(Message, (Message.chat_id == Chat.id) & (Message.timestamp == subquery.c.last_message_time))
        .order_by(desc(subquery.c.last_message_time))
        .limit(limit)
    )
    
    result = await session.execute(stmt)
    rows = result.fetchall()
    
    chats_with_last_messages = []
    for chat, message in rows:
        last_message = LastMessageSchema(
            sender=message.sender,
            content=message.content,
            timestamp=message.timestamp
        )
        chat_response = ChatWithLastMessageResponse(
            chat_id=chat.id,
            last_message=last_message
        )
        chats_with_last_messages.append(chat_response)
    
    return chats_with_last_messages

async def get_last_n_messages(session: AsyncSession, chat: Chat, limit: int = 5) -> List[Message]:
    """
    Получает последние N сообщений из чата.
    """
    stmt = select(Message).where(Message.chat_id == chat.id).order_by(desc(Message.timestamp)).limit(limit)
    result = await session.execute(stmt)
    messages = result.scalars().all()
    return list(reversed(messages))  # Возвращаем в хронологическом порядке


core/models/db_helper.py

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    create_async_engine,
    async_sessionmaker,
    async_scoped_session,
)
from core.config import settings
from asyncio import current_task

class DatabaseHelper:
    def __init__(self, url: str, echo: bool = False):
        self.engine = create_async_engine(url=url, echo=echo)
        self.session_factory = async_sessionmaker(
            bind=self.engine,
            autoflush=False,
            autocommit=False,
            expire_on_commit=False,
        )

    async def get_session(self) -> AsyncSession:
        async with self.session_factory() as session:
            yield session
    
    def get_scoped_session(self):
        session = async_scoped_session(
            session_factory=self.session_factory,
            scopefunc=current_task,
        )
        return session

    async def session_dependency(self) -> AsyncSession:
        async with self.session_factory() as session:
            yield session
            await session.close()

    async def scoped_session_dependency(self) -> AsyncSession:
        session = self.get_scoped_session()
        yield session
        await session.close()

db_helper = DatabaseHelper(url=settings.DATABASE_URL, echo=settings.DB_ECHO)


core/models/message.py

# core/models/message.py
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base
from datetime import datetime
class Message(Base):
    __tablename__ = "messages"
    
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    chat_id: Mapped[int] = mapped_column()
    sender: Mapped[str] = mapped_column()  # 'user' или 'bot'
    content: Mapped[str] = mapped_column()
    timestamp: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    chat: Mapped["Chat"] = relationship("Chat", back_populates="messages")


core/models/user.py

# core/models/user.py
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base

class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[str] = mapped_column(unique=True, index=True)
    chats: Mapped[list["Chat"]] = relationship("Chat", back_populates="user")


docker-compose.yml



requirements.txt

python-dotenv
langchain
langgraph
langchain-community
langchain-postgres
langchain-core
yandexcloud
python-docx
pytesseract
pillow
fastapi
uvicorn[standart]
sqlalchemy[asyncio]
asyncpg
aiofiles
pydantic-settings